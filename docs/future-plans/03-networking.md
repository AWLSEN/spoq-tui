# Networking and Tunneling Architecture

## Overview

Spoq requires secure remote access to Conductor from any device, anywhere. This document covers the networking approaches for both Cloud and Jetson products.

## Goals

1. **Zero-config for users** - Networking "just works"
2. **Secure** - End-to-end encryption, no exposed services
3. **Reliable** - Works behind NATs, firewalls, carrier-grade NAT
4. **Low latency** - Direct connections when possible
5. **Custom domains** - Every user gets `alice.spoq.dev`

## Architecture Comparison

| Aspect | Cloud | Jetson |
|--------|-------|--------|
| SSH exposure | Direct (via ingress) | Via WireGuard tunnel |
| Domain | Subdomain routing | Dynamic DNS |
| NAT traversal | N/A (public server) | UPnP + relay fallback |
| Encryption | TLS + SSH | WireGuard + SSH |
| Relay needed | No | Yes (fallback) |

## Cloud Networking

### Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  CLOUD NETWORKING                                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Cloudflare (DNS + Proxy)                                            │    │
│  │                                                                      │    │
│  │  *.spoq.dev → CNAME → lb.spoq.dev                                   │    │
│  │  (Proxied for DDoS protection)                                      │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Load Balancer / Ingress Controller                                  │    │
│  │                                                                      │    │
│  │  TCP :22 → Route based on SNI or SSH banner                         │    │
│  │  HTTP :443 → Route to web app                                       │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│              ┌─────────────────────┼─────────────────────┐                  │
│              ▼                     ▼                     ▼                  │
│        ┌──────────┐          ┌──────────┐          ┌──────────┐            │
│        │Container │          │Container │          │Container │            │
│        │alice     │          │bob       │          │carol     │            │
│        │:22       │          │:22       │          │:22       │            │
│        └──────────┘          └──────────┘          └──────────┘            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### SSH Routing Options

#### Option 1: SSH Jump Host

Single entry point that routes based on username.

```bash
# User connects with:
ssh alice@ssh.spoq.dev

# Jump host parses username, routes to alice's container
# Implemented via SSH ForceCommand or custom shell
```

```bash
# /etc/ssh/sshd_config on jump host
Match User *
    ForceCommand /usr/local/bin/spoq-router
```

```bash
#!/bin/bash
# /usr/local/bin/spoq-router
USER=$USER
CONTAINER=$(curl -s "http://internal-api/container-for/$USER")
exec ssh -o StrictHostKeyChecking=no $USER@$CONTAINER
```

#### Option 2: Subdomain-based Routing

Each subdomain routes to different container.

```
alice.spoq.dev:22 → Container A
bob.spoq.dev:22   → Container B
```

Requires TCP SNI routing or separate IPs per container (expensive).

#### Option 3: Port-based Routing

Each user gets unique port.

```
ssh.spoq.dev:10001 → alice
ssh.spoq.dev:10002 → bob
```

Simple but less elegant, harder to remember.

### Recommended: Jump Host + ProxyJump

```bash
# User's ~/.ssh/config (generated by web app)
Host spoq
    HostName ssh.spoq.dev
    User alice
    ProxyJump jump.spoq.dev

# Or single command:
ssh -J jump.spoq.dev alice@container-alice
```

### DNS Configuration

```
# Cloudflare DNS records

# Main domain
spoq.dev          A       <web-server-ip>
www.spoq.dev      CNAME   spoq.dev

# SSH entry point
ssh.spoq.dev      A       <jump-host-ip>

# Wildcard for user subdomains (optional, for future web dashboards)
*.spoq.dev        CNAME   lb.spoq.dev

# API
api.spoq.dev      CNAME   spoq.dev
```

## Jetson Networking

### The Challenge

Jetsons are behind home routers with NAT. Need to make them reachable from anywhere.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  THE NAT PROBLEM                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [iPhone on LTE]                              [Jetson at Home]              │
│       │                                              │                       │
│       │ Public IP: 174.x.x.x                        │ Local: 192.168.1.x    │
│       │ (behind carrier NAT)                        │ (behind home NAT)     │
│       │                                              │                       │
│       └──────────────── Internet ───────────────────┘                       │
│                                                                              │
│       Neither can directly connect to the other!                            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Solution: WireGuard + Multiple Fallbacks

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  CONNECTION PRIORITY                                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. Direct WireGuard (UPnP port forward worked)                             │
│     └── Best: lowest latency, no relay                                      │
│                                                                              │
│  2. WireGuard via STUN hole punch                                           │
│     └── Good: works through most NATs                                       │
│                                                                              │
│  3. WireGuard via relay                                                     │
│     └── Fallback: always works, higher latency                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### WireGuard Configuration

#### Jetson (Server)

```ini
# /etc/wireguard/wg0.conf

[Interface]
PrivateKey = <jetson-private-key>
Address = 10.100.0.1/24
ListenPort = 51820
PostUp = iptables -A FORWARD -i wg0 -j ACCEPT
PostDown = iptables -D FORWARD -i wg0 -j ACCEPT

# Profile 1, Device 1 (alice's iPhone)
[Peer]
PublicKey = <iphone-public-key>
AllowedIPs = 10.100.0.10/32

# Profile 1, Device 2 (alice's Mac)
[Peer]
PublicKey = <mac-public-key>
AllowedIPs = 10.100.0.11/32

# Profile 2, Device 1 (bob's iPad)
[Peer]
PublicKey = <ipad-public-key>
AllowedIPs = 10.100.0.20/32

# Profile 2, Device 2 (bob's laptop)
[Peer]
PublicKey = <laptop-public-key>
AllowedIPs = 10.100.0.21/32
```

#### Client Device (iPhone)

```ini
# WireGuard app config

[Interface]
PrivateKey = <iphone-private-key>
Address = 10.100.0.10/32
DNS = 10.100.0.1

[Peer]
PublicKey = <jetson-public-key>
AllowedIPs = 10.100.0.0/24
Endpoint = alice.spoq.dev:51820
PersistentKeepalive = 25
```

### IP Allocation Scheme

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  WIREGUARD IP ALLOCATION                                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Subnet: 10.100.0.0/24                                                      │
│                                                                              │
│  10.100.0.1      Jetson (server)                                           │
│                                                                              │
│  Profile 1 (Owner):                                                         │
│  10.100.0.10     Device 1                                                   │
│  10.100.0.11     Device 2                                                   │
│                                                                              │
│  Profile 2 (Family):                                                        │
│  10.100.0.20     Device 1                                                   │
│  10.100.0.21     Device 2                                                   │
│                                                                              │
│  Reserved:                                                                   │
│  10.100.0.250    Relay server (if needed)                                  │
│  10.100.0.251-254 Future expansion                                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### UPnP Auto Port Forward

```rust
// upnp_manager.rs

use igd::search_gateway;

pub async fn setup_port_forward(local_port: u16, external_port: u16) -> Result<()> {
    let gateway = search_gateway(Default::default()).await?;

    let local_ip = get_local_ip()?;

    gateway.add_port(
        igd::PortMappingProtocol::UDP,
        external_port,
        SocketAddrV4::new(local_ip, local_port),
        3600,  // 1 hour lease
        "Spoq WireGuard"
    ).await?;

    Ok(())
}

pub async fn refresh_port_forward() {
    loop {
        if let Err(e) = setup_port_forward(51820, 51820).await {
            log::warn!("UPnP refresh failed: {}", e);
        }
        tokio::time::sleep(Duration::from_secs(3000)).await; // Refresh every 50 min
    }
}
```

### Dynamic DNS

```rust
// dyndns.rs

const DYNDNS_API: &str = "https://api.spoq.dev/dns";

pub async fn update_dns(subdomain: &str, token: &str) -> Result<()> {
    let public_ip = get_public_ip().await?;

    let client = reqwest::Client::new();
    client.post(format!("{}/update", DYNDNS_API))
        .header("Authorization", format!("Bearer {}", token))
        .json(&json!({
            "subdomain": subdomain,
            "ip": public_ip
        }))
        .send()
        .await?;

    Ok(())
}

pub async fn get_public_ip() -> Result<String> {
    let resp = reqwest::get("https://api.ipify.org").await?;
    Ok(resp.text().await?)
}
```

### Spoq Cloud DNS API

```
# DNS update endpoint
POST /api/dns/update
Auth: Bearer <device-token>
Body: { "subdomain": "alice", "ip": "73.45.123.89" }

# Backend updates Cloudflare via API:
# alice.spoq.dev A 73.45.123.89 (TTL 60s for fast updates)
```

## Relay Server (Fallback)

When direct connection fails (strict NAT, blocked ports), traffic routes through our relay.

### Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  RELAY ARCHITECTURE                                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Spoq Relay Server (relay.spoq.dev)                                  │    │
│  │                                                                      │    │
│  │  ┌──────────────────────────────────────────────────────────────┐   │    │
│  │  │  WireGuard Hub                                                │   │    │
│  │  │                                                               │   │    │
│  │  │  Jetson A ─────┐                                              │   │    │
│  │  │                ├──► Relay ◄──┬───── iPhone A                  │   │    │
│  │  │  Jetson B ─────┤             ├───── iPhone B                  │   │    │
│  │  │                │             │                                │   │    │
│  │  │  Jetson C ─────┘             └───── iPad C                    │   │    │
│  │  │                                                               │   │    │
│  │  └──────────────────────────────────────────────────────────────┘   │    │
│  │                                                                      │    │
│  │  Each Jetson maintains persistent connection to relay.              │    │
│  │  Client devices connect to relay, traffic forwarded to Jetson.     │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Using frp (Fast Reverse Proxy)

Open-source solution for this exact use case.

#### Relay Server (frps)

```ini
# /etc/frp/frps.ini

[common]
bind_port = 7000
bind_udp_port = 7001

# Authentication
authentication_method = token
token = your-secret-token

# Dashboard (optional)
dashboard_port = 7500
dashboard_user = admin
dashboard_pwd = admin

# Subdomain support
subdomain_host = spoq.dev
```

#### Jetson Client (frpc)

```ini
# /etc/frp/frpc.ini

[common]
server_addr = relay.spoq.dev
server_port = 7000
authentication_method = token
token = your-secret-token

[wireguard]
type = udp
local_ip = 127.0.0.1
local_port = 51820
remote_port = 0  # Auto-assign
subdomain = alice  # Results in alice.spoq.dev
```

### Connection Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  CONNECTION DECISION FLOW                                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Device wants to connect to Jetson:                                         │
│                                                                              │
│  1. Try direct connection                                                   │
│     └── DNS lookup: alice.spoq.dev                                         │
│     └── If points to home IP: connect directly                             │
│     └── WireGuard handshake succeeds? ──► DONE (direct mode)              │
│                                                                              │
│  2. If direct fails, try relay                                              │
│     └── Connect to relay.spoq.dev:51820                                    │
│     └── Relay forwards to Jetson                                           │
│     └── Higher latency but always works                                    │
│                                                                              │
│  Decision can be made by:                                                    │
│  a) Client app tries direct first, falls back automatically                 │
│  b) Or: API tells client which endpoint to use based on Jetson status      │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Security Considerations

### WireGuard Security

- **Cryptography**: Curve25519 (key exchange), ChaCha20-Poly1305 (encryption), BLAKE2s (hashing)
- **Perfect forward secrecy**: Yes
- **Key rotation**: Recommended yearly or on device compromise

### Key Management

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  KEY STORAGE                                                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Jetson:                                                                    │
│  └── /etc/wireguard/private.key (mode 600, root only)                      │
│  └── Private key never leaves device                                        │
│                                                                              │
│  Mobile Device:                                                              │
│  └── WireGuard app stores in iOS/Android keychain                          │
│  └── Protected by device biometrics                                         │
│                                                                              │
│  Cloud (API server):                                                        │
│  └── Only stores PUBLIC keys                                                │
│  └── Never sees private keys                                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### SSH Security

```bash
# /etc/ssh/sshd_config on Jetson

# Only allow key-based auth
PasswordAuthentication no
PubkeyAuthentication yes

# Only listen on WireGuard interface
ListenAddress 10.100.0.1

# Restrict to specific users
AllowUsers alice bob

# Disable root login
PermitRootLogin no
```

### Firewall Rules (Jetson)

```bash
# iptables rules

# Allow WireGuard
iptables -A INPUT -p udp --dport 51820 -j ACCEPT

# Allow SSH only from WireGuard subnet
iptables -A INPUT -i wg0 -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -j DROP

# Allow established connections
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Drop everything else
iptables -A INPUT -j DROP
```

## Monitoring and Diagnostics

### Connection Status API

```
GET /api/device/status
Returns:
{
  "wireguard": {
    "interface": "wg0",
    "public_key": "xxx",
    "listen_port": 51820,
    "peers": [
      {
        "public_key": "yyy",
        "endpoint": "174.x.x.x:51820",
        "last_handshake": "2024-01-15T10:30:00Z",
        "transfer_rx": 1048576,
        "transfer_tx": 2097152
      }
    ]
  },
  "upnp": {
    "status": "active",
    "external_ip": "73.x.x.x",
    "external_port": 51820
  },
  "relay": {
    "connected": true,
    "server": "relay.spoq.dev"
  },
  "dns": {
    "subdomain": "alice.spoq.dev",
    "points_to": "73.x.x.x",
    "last_update": "2024-01-15T09:00:00Z"
  }
}
```

### TUI Network Diagnostics

```
$ spoq network status

┌─ Network Status ────────────────────────────────────────────┐
│                                                              │
│  WireGuard: ● Active                                        │
│    Interface: wg0                                           │
│    Address: 10.100.0.1/24                                   │
│    Port: 51820                                              │
│                                                              │
│  Connected Peers:                                           │
│    ● alice-iphone   10.100.0.10   Last: 2s ago             │
│    ○ alice-mac      10.100.0.11   Last: 3h ago             │
│                                                              │
│  External Access:                                           │
│    UPnP: ● Active (port 51820)                             │
│    Public IP: 73.45.123.89                                  │
│    DNS: alice.spoq.dev → 73.45.123.89                      │
│                                                              │
│  Relay: ● Connected (fallback ready)                        │
│                                                              │
│  [t] Test connection  [r] Refresh  [q] Back                │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

## Implementation Checklist

### Cloud Networking
- [ ] Set up Cloudflare DNS with wildcard
- [ ] Configure SSH jump host
- [ ] Implement username-based routing
- [ ] Set up TLS termination
- [ ] Add rate limiting

### Jetson Networking
- [ ] WireGuard auto-configuration
- [ ] UPnP port forwarding
- [ ] Dynamic DNS client
- [ ] Relay client (frpc)
- [ ] Connection health monitoring
- [ ] Automatic failover to relay

### Relay Infrastructure
- [ ] Deploy frps relay server
- [ ] Multi-region relay (US, EU, Asia)
- [ ] Relay authentication
- [ ] Usage monitoring
- [ ] Auto-scaling

### Security
- [ ] Key generation and storage
- [ ] Firewall rules
- [ ] SSH hardening
- [ ] Audit logging
- [ ] Intrusion detection
